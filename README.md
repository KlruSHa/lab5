# Отчет по лабораторной работе №5
## Тема: Отладка кодовой базы проекта на Python с помощью средств отладки

**Цель работы:** закрепление навыков работы с отладчиком; формирование понимания типовых логических и runtime-ошибок; освоение методики поиска, анализа и устранения ошибок.

---

### Ошибка 1: Использование изменяемого значения по умолчанию
* **Тип ошибки:** использование изменяемого значения по умолчанию.
* **Место:** `collections_utils.py`, метод `__init__` класса `BookCollection`.
* **Симптом:** Состояние коллекции книг дублируется между разными независимыми объектами библиотек. Добавление книги в один экземпляр приводит к ее появлению во всех остальных.
* **Как воспроизвести:** Создать два объекта `Library()`, добавить книгу в первый и проверить количество книг во втором.
* **Отладка:**
    * Установлен breakpoint на строку добавления книги `lib1.add_book()`.
    * Далее проверить создание второго объекта
    * В отладчике (окно Variables) видно, что при создании второго объекта аргумент `books` уже содержит данные первого объекта.
    * Анализ идентификаторов показывает, что оба объекта используют одну и ту же область памяти.
* **Причина:** Список `[]` в аргументах функции инициализируется один раз при определении функции и разделяется всеми вызовами.
* **Исправление:** Убрать `books` и сделать инициализацию списка внутри метода: `self._books = []`.
* **Проверка:** Поведение симуляции соответствует ожидаемому.
* **Доказательства:** 

---

### Ошибка 2: Сравнение через is вместо ==
* **Тип ошибки:** сравнение через `is` вместо `==`.
* **Место:** `core.py`, метод `find_by_author`.
* **Симптом:** Поиск не выдает результатов, даже если строковые значения (имена авторов) полностью совпадают.
* **Как воспроизвести:** Запустить поиск по автору, имя которого получаем через ввод.
* **Отладка:**
    * Breakpoint установлен на моменте использования метода поиска по автору.
    * Добавляем в слежение `id(author_name)` и `id(b.author)`
    * В отладчике видно, что значения переменных идентичны, но адреса в памяти разные.
* **Причина:** Оператор `is` проверяет идентичность объектов (адреса в памяти), а не равенство их значений.
* **Исправление:** Заменено на оператор равенства `==`.
* **Проверка:** Поведение симуляции соответствует ожидаемому.
* **Доказательства:** 

---

### Ошибка 3: Изменение пользовательской коллекции во время итерации
* **Тип ошибки:** изменение пользовательской коллекции во время итерации.
* **Место:** `simulation.py`, блок массового удаления книг.
* **Симптом:** Программа не удаляет часть книг, которые подходят под условие удаления.
* **Как воспроизвести:** Выполнить удаление элементов из коллекции непосредственно внутри цикла `for`, который итерируется по этой же коллекции.
* **Отладка:**
    * Выполнен анализ стека вызовов в момент итерации цикла.
    * В окне Locals зафиксировано изменение размера коллекции в процессе обхода.
* **Причина:** Удаление элементов нарушает работу внутреннего итератора.
* **Исправление:** Итерация выполняется по копии списка: `for book in list(library.books):`.
* **Проверка:** Поведение симуляции соответствует ожидаемому.
* **Доказательства:** 

---

### Ошибка 4: Неверное логическое условие
* **Тип ошибки:** неверное логическое условие.
* **Место:** `collections_utils.py`, метод `filter_by_criteria`.
* **Симптом:** Фильтрация возвращает книги, подходящие хотя бы под один критерий вместо всех сразу.
* **Как воспроизвести:** Запустить фильтрацию по нескольким критериям одновременно.
* **Отладка:**
    * Установлен breakpoint на строку `library.books.filter_by_criteria()`
    * Добавим `book.year == 2001` и `book.genre == "Драма"` для удобства отслеживания.
    * В отладчике видно, что выражение всегда `True`, если совпадает хотя бы один параметр, из-за использования `any()`.
* **Причина:** Вместо логического "И" (`all`) использовано логическое "ИЛИ" (`any`).
* **Исправление:** Замена функции `any()` на `all()`.
* **Проверка:** Поведение симуляции соответствует ожидаемому.
* **Доказательства:** 

---

### Ошибка 5: Ошибка границы цикла (off-by-one)
* **Тип ошибки:** ошибка границы цикла (off-by-one).
* **Место:** `simulation.py`, функция `run_simulation`.
* **Симптом:** Симуляция выполняет на один шаг меньше, чем задано в параметрах.
* **Как воспроизвести:** Запустить симуляцию со значением `steps = 5` и проверить лог событий.
* **Отладка:**
    * Установлен breakpoint на заголовок цикла `for`.
    * Пошаговое выполнение показывает, что цикл завершается на значении `steps - 1`.
* **Причина:** Функция `range(1, steps)` не включает верхнюю границу диапазона.
* **Исправление:** Заменено на `range(1, steps + 1)`.
* **Проверка:** Поведение симуляции соответствует ожидаемому.
* **Доказательства:** 